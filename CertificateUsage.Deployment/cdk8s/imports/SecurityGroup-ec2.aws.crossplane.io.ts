// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A SecurityGroup is a managed resource that represents an AWS VPC Security Group.
 *
 * @schema SecurityGroup
 */
export class SecurityGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ec2.aws.crossplane.io/v1beta1',
    kind: 'SecurityGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityGroupProps): any {
    return {
      ...SecurityGroup.GVK,
      ...toJson_SecurityGroupProps(props),
    };
  }

  /**
   * Defines a "SecurityGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityGroupProps) {
    super(scope, id, {
      ...SecurityGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityGroup.GVK,
      ...toJson_SecurityGroupProps(resolved),
    };
  }
}

/**
 * A SecurityGroup is a managed resource that represents an AWS VPC Security Group.
 *
 * @schema SecurityGroup
 */
export interface SecurityGroupProps {
  /**
   * @schema SecurityGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A SecurityGroupSpec defines the desired state of a SecurityGroup.
   *
   * @schema SecurityGroup#spec
   */
  readonly spec: SecurityGroupSpec;

}

/**
 * Converts an object of type 'SecurityGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupProps(obj: SecurityGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecurityGroupSpec defines the desired state of a SecurityGroup.
 *
 * @schema SecurityGroupSpec
 */
export interface SecurityGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SecurityGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityGroupSpecDeletionPolicy;

  /**
   * SecurityGroupParameters define the desired state of an AWS VPC Security Group.
   *
   * @schema SecurityGroupSpec#forProvider
   */
  readonly forProvider: SecurityGroupSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecurityGroupSpec#providerRef
   */
  readonly providerRef?: SecurityGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpec(obj: SecurityGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityGroupSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SecurityGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecurityGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecurityGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SecurityGroupSpecDeletionPolicy
 */
export enum SecurityGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * SecurityGroupParameters define the desired state of an AWS VPC Security Group.
 *
 * @schema SecurityGroupSpecForProvider
 */
export interface SecurityGroupSpecForProvider {
  /**
   * A description of the security group.
   *
   * @schema SecurityGroupSpecForProvider#description
   */
  readonly description: string;

  /**
   * [EC2-VPC] One or more outbound rules associated with the security group.
   *
   * @schema SecurityGroupSpecForProvider#egress
   */
  readonly egress?: SecurityGroupSpecForProviderEgress[];

  /**
   * The name of the security group.
   *
   * @schema SecurityGroupSpecForProvider#groupName
   */
  readonly groupName: string;

  /**
   * Dont manage the egress settings for the created resource
   *
   * @schema SecurityGroupSpecForProvider#ignoreEgress
   */
  readonly ignoreEgress?: boolean;

  /**
   * Dont manage the ingress settings for the created resource
   *
   * @schema SecurityGroupSpecForProvider#ignoreIngress
   */
  readonly ignoreIngress?: boolean;

  /**
   * One or more inbound rules associated with the security group.
   *
   * @schema SecurityGroupSpecForProvider#ingress
   */
  readonly ingress?: SecurityGroupSpecForProviderIngress[];

  /**
   * Region is the region you'd like your SecurityGroup to be created in.
   *
   * @schema SecurityGroupSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Tags represents to current ec2 tags.
   *
   * @schema SecurityGroupSpecForProvider#tags
   */
  readonly tags?: SecurityGroupSpecForProviderTags[];

  /**
   * VPCID is the ID of the VPC.
   *
   * @schema SecurityGroupSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef references a VPC to and retrieves its vpcId
   *
   * @schema SecurityGroupSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderVpcIdRef;

  /**
   * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
   *
   * @schema SecurityGroupSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProvider(obj: SecurityGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_SecurityGroupSpecForProviderEgress(y)),
    'groupName': obj.groupName,
    'ignoreEgress': obj.ignoreEgress,
    'ignoreIngress': obj.ignoreIngress,
    'ingress': obj.ingress?.map(y => toJson_SecurityGroupSpecForProviderIngress(y)),
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_SecurityGroupSpecForProviderTags(y)),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityGroupSpecProviderConfigRef
 */
export interface SecurityGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderConfigRef(obj: SecurityGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecurityGroupSpecProviderRef
 */
export interface SecurityGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecProviderRef#policy
   */
  readonly policy?: SecurityGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderRef(obj: SecurityGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsTo
 */
export interface SecurityGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsTo(obj: SecurityGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityGroupSpecWriteConnectionSecretToRef
 */
export interface SecurityGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecWriteConnectionSecretToRef(obj: SecurityGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPPermission Describes a set of permissions for a security group rule.
 *
 * @schema SecurityGroupSpecForProviderEgress
 */
export interface SecurityGroupSpecForProviderEgress {
  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderEgress#fromPort
   */
  readonly fromPort?: number;

  /**
   * The IP protocol name (tcp, udp, icmp, icmpv6) or number (see Protocol Numbers (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
   * [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @schema SecurityGroupSpecForProviderEgress#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The IPv4 ranges.
   *
   * @schema SecurityGroupSpecForProviderEgress#ipRanges
   */
  readonly ipRanges?: SecurityGroupSpecForProviderEgressIpRanges[];

  /**
   * The IPv6 ranges.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderEgress#ipv6Ranges
   */
  readonly ipv6Ranges?: SecurityGroupSpecForProviderEgressIpv6Ranges[];

  /**
   * PrefixListIDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderEgress#prefixListIds
   */
  readonly prefixListIds?: SecurityGroupSpecForProviderEgressPrefixListIds[];

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderEgress#toPort
   */
  readonly toPort?: number;

  /**
   * UserIDGroupPairs are the source security group and AWS account ID pairs. It contains one or more accounts and security groups to allow flows from security groups of other accounts.
   *
   * @schema SecurityGroupSpecForProviderEgress#userIdGroupPairs
   */
  readonly userIdGroupPairs?: SecurityGroupSpecForProviderEgressUserIdGroupPairs[];

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgress(obj: SecurityGroupSpecForProviderEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipProtocol': obj.ipProtocol,
    'ipRanges': obj.ipRanges?.map(y => toJson_SecurityGroupSpecForProviderEgressIpRanges(y)),
    'ipv6Ranges': obj.ipv6Ranges?.map(y => toJson_SecurityGroupSpecForProviderEgressIpv6Ranges(y)),
    'prefixListIds': obj.prefixListIds?.map(y => toJson_SecurityGroupSpecForProviderEgressPrefixListIds(y)),
    'toPort': obj.toPort,
    'userIdGroupPairs': obj.userIdGroupPairs?.map(y => toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPPermission Describes a set of permissions for a security group rule.
 *
 * @schema SecurityGroupSpecForProviderIngress
 */
export interface SecurityGroupSpecForProviderIngress {
  /**
   * The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderIngress#fromPort
   */
  readonly fromPort?: number;

  /**
   * The IP protocol name (tcp, udp, icmp, icmpv6) or number (see Protocol Numbers (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
   * [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
   *
   * @schema SecurityGroupSpecForProviderIngress#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The IPv4 ranges.
   *
   * @schema SecurityGroupSpecForProviderIngress#ipRanges
   */
  readonly ipRanges?: SecurityGroupSpecForProviderIngressIpRanges[];

  /**
   * The IPv6 ranges.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderIngress#ipv6Ranges
   */
  readonly ipv6Ranges?: SecurityGroupSpecForProviderIngressIpv6Ranges[];

  /**
   * PrefixListIDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.
   * [VPC only]
   *
   * @schema SecurityGroupSpecForProviderIngress#prefixListIds
   */
  readonly prefixListIds?: SecurityGroupSpecForProviderIngressPrefixListIds[];

  /**
   * The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
   *
   * @schema SecurityGroupSpecForProviderIngress#toPort
   */
  readonly toPort?: number;

  /**
   * UserIDGroupPairs are the source security group and AWS account ID pairs. It contains one or more accounts and security groups to allow flows from security groups of other accounts.
   *
   * @schema SecurityGroupSpecForProviderIngress#userIdGroupPairs
   */
  readonly userIdGroupPairs?: SecurityGroupSpecForProviderIngressUserIdGroupPairs[];

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngress(obj: SecurityGroupSpecForProviderIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'ipProtocol': obj.ipProtocol,
    'ipRanges': obj.ipRanges?.map(y => toJson_SecurityGroupSpecForProviderIngressIpRanges(y)),
    'ipv6Ranges': obj.ipv6Ranges?.map(y => toJson_SecurityGroupSpecForProviderIngressIpv6Ranges(y)),
    'prefixListIds': obj.prefixListIds?.map(y => toJson_SecurityGroupSpecForProviderIngressPrefixListIds(y)),
    'toPort': obj.toPort,
    'userIdGroupPairs': obj.userIdGroupPairs?.map(y => toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag defines a tag
 *
 * @schema SecurityGroupSpecForProviderTags
 */
export interface SecurityGroupSpecForProviderTags {
  /**
   * Key is the name of the tag.
   *
   * @schema SecurityGroupSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * Value is the value of the tag.
   *
   * @schema SecurityGroupSpecForProviderTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderTags(obj: SecurityGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef references a VPC to and retrieves its vpcId
 *
 * @schema SecurityGroupSpecForProviderVpcIdRef
 */
export interface SecurityGroupSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdRef(obj: SecurityGroupSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects a reference to a VPC to and retrieves its vpcId
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelector
 */
export interface SecurityGroupSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdSelector(obj: SecurityGroupSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicy
 */
export interface SecurityGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderConfigRefPolicy(obj: SecurityGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecProviderRefPolicy
 */
export interface SecurityGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecProviderRefPolicy(obj: SecurityGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRef(obj: SecurityGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToMetadata(obj: SecurityGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPRange describes an IPv4 range.
 *
 * @schema SecurityGroupSpecForProviderEgressIpRanges
 */
export interface SecurityGroupSpecForProviderEgressIpRanges {
  /**
   * The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.
   *
   * @schema SecurityGroupSpecForProviderEgressIpRanges#cidrIp
   */
  readonly cidrIp: string;

  /**
   * A description for the security group rule that references this IPv4 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressIpRanges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressIpRanges(obj: SecurityGroupSpecForProviderEgressIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIp': obj.cidrIp,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv6Range describes an IPv6 range.
 *
 * @schema SecurityGroupSpecForProviderEgressIpv6Ranges
 */
export interface SecurityGroupSpecForProviderEgressIpv6Ranges {
  /**
   * The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.
   *
   * @schema SecurityGroupSpecForProviderEgressIpv6Ranges#cidrIPv6
   */
  readonly cidrIPv6: string;

  /**
   * A description for the security group rule that references this IPv6 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressIpv6Ranges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressIpv6Ranges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressIpv6Ranges(obj: SecurityGroupSpecForProviderEgressIpv6Ranges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIPv6': obj.cidrIPv6,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrefixListID describes a prefix list ID.
 *
 * @schema SecurityGroupSpecForProviderEgressPrefixListIds
 */
export interface SecurityGroupSpecForProviderEgressPrefixListIds {
  /**
   * A description for the security group rule that references this prefix list ID.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressPrefixListIds#description
   */
  readonly description?: string;

  /**
   * The ID of the prefix.
   *
   * @schema SecurityGroupSpecForProviderEgressPrefixListIds#prefixListId
   */
  readonly prefixListId: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressPrefixListIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressPrefixListIds(obj: SecurityGroupSpecForProviderEgressPrefixListIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'prefixListId': obj.prefixListId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserIDGroupPair describes a security group and AWS account ID pair.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairs {
  /**
   * A description for the security group rule that references this user ID group pair.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#description
   */
  readonly description?: string;

  /**
   * The ID of the security group.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupId
   */
  readonly groupId?: string;

  /**
   * GroupIDRef reference a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupIdRef
   */
  readonly groupIdRef?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef;

  /**
   * GroupIDSelector selects reference to a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupIdSelector
   */
  readonly groupIdSelector?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector;

  /**
   * The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
   * For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#groupName
   */
  readonly groupName?: string;

  /**
   * The ID of an AWS account.
   * For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.
   * [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#userId
   */
  readonly userId?: string;

  /**
   * The ID of the VPC for the referenced security group, if applicable.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef reference a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef;

  /**
   * VPCIDSelector selects reference to a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector;

  /**
   * The ID of the VPC peering connection, if applicable.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairs#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairs(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'groupId': obj.groupId,
    'groupIdRef': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector(obj.groupIdSelector),
    'groupName': obj.groupName,
    'userId': obj.userId,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector(obj.vpcIdSelector),
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPRange describes an IPv4 range.
 *
 * @schema SecurityGroupSpecForProviderIngressIpRanges
 */
export interface SecurityGroupSpecForProviderIngressIpRanges {
  /**
   * The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.
   *
   * @schema SecurityGroupSpecForProviderIngressIpRanges#cidrIp
   */
  readonly cidrIp: string;

  /**
   * A description for the security group rule that references this IPv4 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressIpRanges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressIpRanges(obj: SecurityGroupSpecForProviderIngressIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIp': obj.cidrIp,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv6Range describes an IPv6 range.
 *
 * @schema SecurityGroupSpecForProviderIngressIpv6Ranges
 */
export interface SecurityGroupSpecForProviderIngressIpv6Ranges {
  /**
   * The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.
   *
   * @schema SecurityGroupSpecForProviderIngressIpv6Ranges#cidrIPv6
   */
  readonly cidrIPv6: string;

  /**
   * A description for the security group rule that references this IPv6 address range.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressIpv6Ranges#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressIpv6Ranges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressIpv6Ranges(obj: SecurityGroupSpecForProviderIngressIpv6Ranges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrIPv6': obj.cidrIPv6,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrefixListID describes a prefix list ID.
 *
 * @schema SecurityGroupSpecForProviderIngressPrefixListIds
 */
export interface SecurityGroupSpecForProviderIngressPrefixListIds {
  /**
   * A description for the security group rule that references this prefix list ID.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressPrefixListIds#description
   */
  readonly description?: string;

  /**
   * The ID of the prefix.
   *
   * @schema SecurityGroupSpecForProviderIngressPrefixListIds#prefixListId
   */
  readonly prefixListId: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressPrefixListIds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressPrefixListIds(obj: SecurityGroupSpecForProviderIngressPrefixListIds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'prefixListId': obj.prefixListId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserIDGroupPair describes a security group and AWS account ID pair.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairs {
  /**
   * A description for the security group rule that references this user ID group pair.
   * Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#description
   */
  readonly description?: string;

  /**
   * The ID of the security group.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupId
   */
  readonly groupId?: string;

  /**
   * GroupIDRef reference a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupIdRef
   */
  readonly groupIdRef?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef;

  /**
   * GroupIDSelector selects reference to a security group to retrieve its GroupID
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupIdSelector
   */
  readonly groupIdSelector?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector;

  /**
   * The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
   * For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#groupName
   */
  readonly groupName?: string;

  /**
   * The ID of an AWS account.
   * For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.
   * [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#userId
   */
  readonly userId?: string;

  /**
   * The ID of the VPC for the referenced security group, if applicable.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcId
   */
  readonly vpcId?: string;

  /**
   * VPCIDRef reference a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcIdRef
   */
  readonly vpcIdRef?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef;

  /**
   * VPCIDSelector selects reference to a VPC to retrieve its vpcId
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcIdSelector
   */
  readonly vpcIdSelector?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector;

  /**
   * The ID of the VPC peering connection, if applicable.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairs#vpcPeeringConnectionId
   */
  readonly vpcPeeringConnectionId?: string;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairs(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'groupId': obj.groupId,
    'groupIdRef': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector(obj.groupIdSelector),
    'groupName': obj.groupName,
    'userId': obj.userId,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector(obj.vpcIdSelector),
    'vpcPeeringConnectionId': obj.vpcPeeringConnectionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdRefPolicy(obj: SecurityGroupSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicyResolution
 */
export enum SecurityGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecProviderConfigRefPolicyResolve
 */
export enum SecurityGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecProviderRefPolicyResolution
 */
export enum SecurityGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecProviderRefPolicyResolve
 */
export enum SecurityGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDRef reference a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDSelector selects reference to a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef reference a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects reference to a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDRef reference a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupIDSelector selects reference to a security group to retrieve its GroupID
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDRef reference a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCIDSelector selects reference to a VPC to retrieve its vpcId
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector#policy
   */
  readonly policy?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy
 */
export interface SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy(obj: SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderEgressUserIdGroupPairsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve
 */
export enum SecurityGroupSpecForProviderIngressUserIdGroupPairsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

